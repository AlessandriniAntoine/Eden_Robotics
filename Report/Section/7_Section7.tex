\section{ROS}\insertloftspace
\setcounter{figure}{0}\setcounter{table}{0}

For our project, we used ros1 noetic.

\subsection{Definition}

\hspace{\parindent} As the name suggests, ROS (Robot Operating System) is an operating system for robots. Like operating systems for PCs, servers or stand-alone devices, ROS is a complete operating system for service robotics.

\bigbreak
It is composed of a set of free open source software allowing to develop software for robotics. ROS is a meta operating system, something between the operating system and the middleware.

\bigbreak
ROS is therefore positioned as a facilitator of robotics projects. Researchers or engineers in R\&D departments no longer spend time creating a new ecosystem for each new robotics project. ROS has an accelerating effect on R\&D by reducing costs and time to market. It is therefore very interesting for the rapid development of a prototype

\bigbreak
\textbf{Master:} The master is a ROS process that helps nodes locate each other and establish communication channels based on their publisher subscriber relationships and any services. The master also manages the parameter server. The master is typically started through the roscore command-line tool, or it is automatically started via a roslaunch call.

\bigbreak
\textbf{Topic:} A topic is a many-to-many information transport system. It is typed, it is necessary to specify which type of messages we transport and based on the system of subscription / publication 

\bigbreak
\textbf{Node:} A node is an instance of an executable; it can be linked to an engine, a sensor, or purely software. A node can post messages to a topic or subscribe to messages in a topic. They are independent processes, the crash of a node does not crash the whole ROS (Notion of micro-kernel on which ROS is based)

\bigbreak
\textbf{Launch file:} Launch files are very common in ROS to both users and developers. They provide a convenient way to start up multiple nodes and a master, as well as other initialization requirements such as setting parameters.

\bigbreak
\textbf{Package:} A collection of source code, configuration files, and other resources that implements functionality in ROS. By dividing related functionality into packages, it can be shared with others and reused across projects. All packages must have a package.xml file defining its manifest.

\bigbreak
\textbf{Workspace:} A workspace is a folder where you modify, build, and install packages.

\subsection{Training}

\hspace{\parindent} Following the advice of our consultant, we quickly understood the advantage of using ROS. For that, the members of the automatic pole followed trainings to understand how to use it, to understand the principle, the functioning and the possible applications. Fortunately, the site offers many tutorials to learn through practice. This training was necessary and should be done as soon as possible to become familiar with totally foreign tools. We did everything using python and because we had developed everything with it. 

\bigbreak
This training on ROS is over. We knew how to create a workspace, packages and nodes. We also decided to link Matlab and ROS to accelerate the development. So we followed the tutorials proposed by matlab for the use of ROS with simulink and the development of package from model Simulink. This allowed to accelerate the tests but especially the handling of ROS because the commands were relatively automated by Matlab. However, we were less free for the package creation. Indeed, once the model is generated, it is difficult to directly modify the package code. You have to go back to the Simulink model and regenerate the package. Once we understood how python packages work, we limited the export of Simulink to packages. We still continued to use the connection between ROS and Matlab for testing.

\subsection{Packages}
\hspace{\parindent} For this project, we decided to separate the tools by categories. Four packages have been created and one is from an existing ROS package.
\begin{itemize}
    \item \textbf{arm} : It contains all the nodes concerning the arm (forward kinematics, change frame, joystick conversion). It also contains all the information about the arm (kinematics parameters, rviz file, gazebo file, stl file) allowing the simulation with ROS only.
    \item \textbf{inverse kinematics} : The inverse kinematics having been generated from Simulink, it constitutes a separate package containing only the inverse kinematics node.
    \item  \textbf{motors} : It contains all the codes related to the motors. The node that listens to the instructions and sends them to the engines.
    \item  \textbf{camera} : It contains all nodes related to the camera (webcam display, object tracking, object detection)
    \item  \textbf{joy} : It allows to get Xbox controller data.
\end{itemize}

\subsection{Topics}

\hspace{\parindent} We list here all the topics that will be used in the command chain. Be careful, inside the nodes, they can have different names to be more generic and reusable in other projects without having to modify them. But as we will see, we can change the name of these topics at the time of launch to give them a new value linked to the project. It is therefore this name that we make explicit. 
\begin{itemize}
    \item /Joystick/ref/joy : [Joy (sensor\_msgs)] joystick movement and button pressed
    \item /Camera/ref/position : [Point (geometry\_msgs)] command position in camera frame
    \item /Robot/ref/position : [Point (geometry\_msgs)] command position in base frame
    \item /Robot/state/joint : [JointState (sensor\_msgs)] position of each joints
    \item /Robot/state/measure : [PoseStamped (geometry\_msgs)] end effector position in base frame
    \item /Robot/state/reference : [PointStamped (geometry\_msgs)] end effector target position in base frame
    \item /EndEffector/state/position : [Point (geometry\_msgs)] end effector state position in base frame (forward kinematics)
    \item /Motors/state/current : [JointState (sensor\_msgs)] current delivered by each motors
    \item /Motors/state/present\_position : [JointState (sensor\_msgs)] real position of each motors
\end{itemize}
\subsection{Nodes}
\hspace{\parindent} To start a node, you have to source ROS, source the workspace that contains the package if this has not been done in the terminal and then launch the node.
\begin{commandshell}
    source /opt/ros/noetic/setup.bash
    roscore
    rosrun <package_name> <node_name>
\end{commandshell}

\subsubsection{Forward kinematics}

\hspace{\parindent} La forward kinematics fonctionnait très bien avec python avec des résultats équivalents à $10^{-4}m$ par rapport au model simulink. Nous sommes donc partie de ce fichier pour créer le node. Ce node fait partie du package arm. 

\subsubsection{Inverse kinematics}

\hspace{\parindent} The inverse kinematics node was created from simulink. The python model did not provide any results, so it was easier to use the code generator of matlab.

\bigbreak
The node subscribes to the topic \textit{\textbackslash Robot\textbackslash ref\textbackslash position} and publish the topic \textit{\textbackslash Robot\textbackslash ref\textbackslash joint}. It publishes the x,y,z coordinates of the desired position. The output topic publishes a list containing the position of each link as well as an other one with their names and a header indicating the time.
\bigbreak
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Section07/Inverse\_kinematics\_node.png}
    \caption{Inverse kinematics node}
    \label{fig:mesh21}
\end{figure}
\FloatBarrier

\bigbreak
To connect to ROS with Matlab you will need to configure ROS Network Adress.You can access this in the \textbf{Simulation tab} by selecting \textbf{ROS Toolbox} $\bg$ \textbf{ROS Network}. You will need to set :
\begin{multicols}{2}
    \begin{itemize}[noitemsep]
        \item ROS Master
        \item Network Adress
    \end{itemize}
\end{multicols}

\bigbreak
To run files that contain ros block, you need a ROS master. You can run it on a terminal with the following commande :
\begin{commandshell}
    source /opt/ros/noetic/setup.bash
    roscore
\end{commandshell} 

\bigbreak
The ros folder contains files that are generated by Matlab to create ros packaga from a simulink file. To generate them you need set parameters. You can access this in the \textbf{modeling tab} $\bg$ \textbf{Model Settings} $\bg$ \textbf{Hardware Implementation} $\bg$ \textbf{Hardware board settings} $\bg$ \textbf{Target hardware resources} $\bg$ \textbf{Groups} $\bg$ \textbf{Build Options}. You need to set :
\begin{itemize}[noitemsep]
    \item Device Adress (127.0.0.1 if localhost)
    \item Username
    \item password
    \item Ros folder (already set)
    \item path to catkin workspace
\end{itemize}

\bigbreak
Then you just have to generate the files. It will create :
\begin{multicols}{2}
    \begin{itemize}[noitemsep]
        \item build\_ros\_model.sh
        \item $\less$model\_name$\bg$.tgz
    \end{itemize}
\end{multicols}


\bigbreak
From the folder where are the files, you can now create your package with the following command. The package and the node will have the same name as the simulink model.
\begin{commandshell}
    ./build_ros_model.sh <model>.tgz <catkin_workspace_path>
\end{commandshell} 



\subsubsection{Change frame}

\subsubsection{Motors}

\subsubsection{Camera}

\subsection{Launch files}
\subsubsection{Rviz}

\subsubsection{Inverse kinematics}

\subsubsection{Open loop}

\subsubsection{Closed loop}